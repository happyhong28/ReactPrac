{"version":3,"sources":["Movie.js","App.js","reportWebVitals.js","index.js"],"names":["MoviePoster","poster","alt","src","title","className","MovieGenres","genres","Movie","synopsis","map","index","text","maxLine","ellipsis","trimRight","basedOn","App","state","_renderMovies","movies","movie","title_english","medium_cover_image","id","_getMovies","a","_callApi","setState","fetch","then","response","json","data","catch","err","console","log","this","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"0SAkFA,SAASA,EAAT,GAAuC,IAAhBC,EAAe,EAAfA,OAAQC,EAAO,EAAPA,IAC7B,OACE,qBAAKC,IAAKF,EAAQC,IAAKA,EAAKE,MAAOF,EAAKG,UAAU,kBAItD,SAASC,EAAT,GAAkC,IAAXC,EAAU,EAAVA,OACrB,OACE,uBAAMF,UAAU,gBAAhB,UAAkCE,EAAlC,OAgBWC,MA3Ef,YAAqD,IAApCJ,EAAmC,EAAnCA,MAAOH,EAA4B,EAA5BA,OAAQM,EAAoB,EAApBA,OAAQE,EAAY,EAAZA,SACtC,OACE,sBAAKJ,UAAU,QAAf,UACE,qBAAKA,UAAU,gBAAf,SAEE,cAACL,EAAD,CAAaC,OAAQA,EAAQC,IAAKE,MAGpC,sBAAKC,UAAU,gBAAf,UACE,6BAAKD,IACL,qBAAKC,UAAU,gBAAf,SACGE,EAAOG,KAAI,SAACH,EAAQI,GAAT,OAAmB,cAACL,EAAD,CAAaC,OAAQA,GAAaI,QAGnE,qBAAKN,UAAU,kBAAf,SACA,cAAC,IAAD,CACEO,KAAMH,EACNI,QAAQ,IACRC,SAAS,MACTC,WAAS,EACTC,QAAQ,qBCwGHC,E,4MAjJbC,MAAQ,G,EA+DRC,cAAgB,WAad,OAZe,EAAKD,MAAME,OAAOV,KAAI,SAACW,GAKpC,OAAO,cAAC,EAAD,CACPjB,MAAOiB,EAAMC,cACbrB,OAAQoB,EAAME,mBACdhB,OAAQc,EAAMd,OACdE,SAAUY,EAAMZ,UACXY,EAAMG,Q,EAKfC,W,sBAAa,4BAAAC,EAAA,sEACU,EAAKC,WADf,OACLP,EADK,OAMX,EAAKQ,SAAS,CACZR,WAPS,2C,EAcbO,SAAW,WACT,OAAOE,MAAM,yDACVC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,SAAAE,GAAI,OAAIA,EAAKC,KAAKb,UACvBc,OAAM,SAAAC,GAAG,OAAIC,QAAQC,IAAIF,O,uDA/F9B,WAEEG,KAAKb,e,oBAmGP,WACE,OACE,qBAAKpB,UAAYiC,KAAKpB,MAAME,OAAS,MAAQ,eAA7C,SAuBGkB,KAAKpB,MAAME,OAASkB,KAAKnB,gBAAkB,gB,GAlIlCoB,aCIHC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBZ,MAAK,YAAkD,IAA/Ca,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCOdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAG1BZ,M","file":"static/js/main.0df5342f.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport PropTypes, { func } from 'prop-types';\r\nimport './Movie.css';\r\nimport LinesEllipsis from 'react-lines-ellipsis'\r\n\r\n// class Movie extends Component {\r\n\r\n//  //해당 props에 원하는 값만 출력하도록 설정\r\n//  //isRequired가 있으면 필수값이라는 의미\r\n//  //데이터가 없으면 에러메세지를 띄워준다.\r\n//  static propTypes = {\r\n//   title: PropTypes.string.isRequired,\r\n//   poster: PropTypes.string.isRequired\r\n// }\r\n\r\n\r\n//   //컴포넌트는 항상 render가 필수!\r\n//   render() {\r\n//     // console.log(this.props);\r\n//     return (\r\n//       <div>\r\n//         <MoviePoster poster={this.props.poster}/> \r\n//         {/* 큰 컴포넌트 안에 작은 컴포넌트를 집어넣는 방식 */}\r\n\r\n//         <h1>{this.props.title}</h1>\r\n//         {/* movie[0],[1]...을 순서대로 적용시킨다. */}\r\n//       </div>\r\n//     );\r\n//   }\r\n// }\r\n\r\nfunction Movie({ title, poster, genres, synopsis }) {\r\n  return (\r\n    <div className=\"Movie\">\r\n      <div className=\"Movie__Column\">\r\n        {/* 클래스가 아니니까 앞에 this.props를 적어줄 필요가 없다 */}\r\n        <MoviePoster poster={poster} alt={title} />\r\n      </div>\r\n\r\n      <div className=\"Movie__Column\">\r\n        <h1>{title}</h1>\r\n        <div className=\"Movie__Genres\">\r\n          {genres.map((genres, index) => <MovieGenres genres={genres} key={index} />)}\r\n        </div>\r\n        {/* <p className=\"Movie__Synopsis\">{synopsis}</p> */}\r\n        <div className=\"Movie__Synopsis\">\r\n        <LinesEllipsis\r\n          text={synopsis}\r\n          maxLine='3'\r\n          ellipsis='...'\r\n          trimRight\r\n          basedOn='letters'\r\n        />\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n\r\n}\r\n\r\nMoviePoster.propTypes = {\r\n  title: PropTypes.string.isRequired,\r\n  poster: PropTypes.string.isRequired,\r\n  genres: PropTypes.string.isRequired,\r\n  synopsis: PropTypes.string.isRequired\r\n}\r\n\r\n\r\n// class MoviePoster extends Component {\r\n\r\n//   static propTypes = {\r\n//     poster: PropTypes.string.isRequired\r\n//   }\r\n\r\n//   render() {\r\n//     return (\r\n//       <img src={this.props.poster} />\r\n//     )\r\n//   }\r\n// }\r\n\r\n//이 functional 컴포넌트는 위의 class 컴포넌트와 완전히 동일한 기능을 수행한다.\r\nfunction MoviePoster({ poster, alt }) {\r\n  return (\r\n    <img src={poster} alt={alt} title={alt} className=\"Movie__Poster\" />\r\n  )\r\n}\r\n\r\nfunction MovieGenres({ genres }) {\r\n  return (\r\n    <span className=\"Movie__Genres\" >{genres} </span> //장르끼리 보기 좋게 간격주기!  \r\n  )\r\n\r\n}\r\n\r\nMoviePoster.propTypes = {\r\n  poster: PropTypes.string.isRequired,\r\n  alt: PropTypes.string.isRequired\r\n\r\n}\r\n\r\nMovieGenres.propTypes = {\r\n  genres: PropTypes.string.isRequired\r\n\r\n}\r\n\r\nexport default Movie; // app.js로 이 컴포넌트를 export한다는 의미","import React, { Component } from 'react';\nimport './App.css';\nimport Movie from './Movie'; //Movie.js에서 export했으니까 여기서 import해서 사용!\n\n\n\n// 데이터는 메인 컴포넌트가 모두 갖고 있다.\n\nclass App extends Component {\n\n  state = {}\n\n  componentDidMount() {\n\n    this._getMovies();\n\n    // 실제 영화 데이터\n    //  fetch(\"https://yts.mx/api/v2/list_movies.json?sort_by=rating\")\n    //  .then(response => response.json()) //fetch의 결과물을 json형태로 변환 (response의 이름은 뭐든지 바꿀수있음! 그냥 변수일뿐!)\n    //  .then(json => console.log(json))\n    //  .catch(err => console.log(err))\n    // console.log(fetch(\"https://yts.mx/api/v2/list_movies.json?sort_by=rating\"));\n    // 기본적으로 ajax는 비동기이므로 이전 코드가 끝나지 않으면\n    // 다음 코드로 넘어가지 않음.   \n    // 하지만 이것을 바꿔주는게 promise이다. promise는 동기방식!\n\n\n\n\n    // 실습을 위한 가데이터\n    // setTimeout(() => {\n    //   this.setState({\n\n    //     movies: [\n    //       {\n    //         title: \"Matrix\",\n    //         poster: \"https://cdn.europosters.eu/image/1300/posters/matrix-hackers-i104636.jpg\"\n    //       },\n    //       {\n    //         title: \"Full Metal Jacket\",\n    //         poster: \"https://img.fruugo.com/product/6/12/14264126_max.jpg\"\n    //       },\n    //       {\n    //         title: \"Oldboy\",\n    //         poster: \"https://i.pinimg.com/originals/f0/cd/db/f0cddb397d73979f09921485227b5879.jpg\"\n    //       },\n    //       {\n    //         title: \"Star Wars\",\n    //         poster: \"https://starwarsblog.starwars.com/wp-content/uploads/2017/12/the-last-jedi-dolby-poster.jpg\"\n    //       },\n    //       {\n    //         title: \"Trainspotting\",\n    //         poster: \"https://m.media-amazon.com/images/I/51oFj1gwDyL._AC_.jpg\"\n\n    //       }\n    //     ]\n\n    //     // movies: [\n    //     //   ...this.state.movies, \n    //     //   //이 코드가 없으면 리스트에 추가되는게 아니라 대체된다.\n    //     //   {\n    //     //     title: \"Trainspotting\",\n    //     //     poster: \"https://m.media-amazon.com/images/I/51oFj1gwDyL._AC_.jpg\"\n\n    //     //   }\n    //     // ]\n    //   })\n    // }, 3000)\n  }\n\n\n  // 영화리스트를 렌더링하는 함수\n  // 내가 만든 함수 앞에 _를 붙여서 구분해주는 것이 좋다.\n  _renderMovies = () => {\n    const movies = this.state.movies.map((movie) => {\n      // console.log(movie);\n      // 이 데이터 안에는 id 값이 있어서 id로 구분했지만, \n      // 없다면 index값을 이용하면 된다. \n      // 하지칸 index를 사용하면 느려지므로 사용 지양할 것\n      return <Movie \n      title={movie.title_english} \n      poster={movie.medium_cover_image} \n      genres={movie.genres}\n      synopsis={movie.synopsis} \n      key={movie.id} />\n    })\n    return movies\n  }\n\n  _getMovies = async () => {\n    const movies = await this._callApi();\n    // await의 역할은 callApi()가 끝나기를 기다리는 것\n    // 그리고 callApi()의 return값이 무엇이든 간에 movies라는 변수에 저장한다.\n    // async를 쓰지않으면 await가 작동X\n\n    this.setState({\n      movies // 이 컴포넌트의 setState를 movies로 한다.\n    })\n    // 그리고 이 setState는 callApi 작업이 끝나기 전까지는 실행X\n    // 항상 promise를 반환한다.\n\n  }\n\n  _callApi = () => {\n    return fetch(\"https://yts.mx/api/v2/list_movies.json?sort_by=rating\")\n      .then(response => response.json()) //fetch의 결과물을 json형태로 변환 (response의 이름은 뭐든지 바꿀수있음! 그냥 변수일뿐!)\n      .then(json => json.data.movies)\n      .catch(err => console.log(err))\n    // => 는 allow function으로 모던js 이며 return이라는 뜻이 내재되어있음.\n\n  }\n\n  // 모든 컴포넌트는 render를 가진다.\n  render() {\n    return (\n      <div className={ this.state.movies ? \"App\" : \"App--loading\"}> \n      {/* movies가 존재여부에 따라 클래스이름을 다르게 설정*/}\n        {/* \n          처음에는 Hello 라는 문자열을 출력하고,\n          5초가 지나면, Hello again이라는 문자열로 바뀌게 한다.\n          state를 바꿀때는 setState를 사용해야하고,\n          바뀔때마다 render가 작동한다.        \n        */}\n        {\n          /* <Movie title={movieTitles[0]} poster={movieImages[0]} />\n          <Movie title={movieTitles[1]} poster={movieImages[1]} />\n          <Movie title={movieTitles[2]} poster={movieImages[2]} />\n          <Movie title={movieTitles[3]} poster={movieImages[3]} /> */\n        }\n        {/* \n        - Movie라는 컴포넌트를 불러오는 형태 \n        - 영화의 제목을 children component인 movie 컴포넌트에 보낸다!\n        - 위의 4줄은 아래 map을 활용한 코드와 동일한 기능을 수행한다.\n        */\n        }\n\n\n\n        {this.state.movies ? this._renderMovies() : 'Loading'}\n        {/* {this.state.movies.map((movie, index) => {\n          return <Movie title={movie.title} poster={movie.poster} key={index} />\n        })} */}\n        {/* \n        - movies 라는 배열을 가져다가 mapping해서\n        - movies 배열 안의 요소를 활용해서 movie라는 새로운 배열을 만드는 개념\n        - jquery할때 배운 rendering의 개념과 유사한 것 같다.   \n        - 언제나 return은 필수!     \n        */}\n\n\n      </div>\n    );\n  }\n}\n\nexport default App; // app.js로 이 컴포넌트를 export한다는 의미\n\n\n\n\n// 동작순서\n// 1. Movie.js 에서 MoviePoster, MovieGenres 라는 small 함수형 컴포넌트를 생성\n// 2. 각 컴포넌트를 통해 포스터 URL, 장르에 대한 text 값 받아서 html로 출력\n// 3. propTypes을 통해 받아오는 값이 string값이 맞는지도 체크\n// 4. 그 small 함수형 컴포넌트를 Movie 라는 big 함수형 컴포넌트에서 조각을 붙여서 틀 완성\n// 5. App.js로 export\n// 6. App.js에서 import\n// 7. _getMovies 함수를 호출\n// 8. _getMovies는 _callApi가 끝날때까지 기다렸다가 _callApi가 끝나면 그 결과값을 movies에 setState한다.\n// 9. 그리고 모든 컴포넌트가 기본적으로 갖는 render()에서 movies에 값이 있는지 체크를 한다.\n// 10. 값이 있을때만 _renderMovies 함수를 실행하고, 없다면 loading 이라는 문자열 출력\n// 11. _renderMovies 함수가 실행되면, import했던 Movie라는 big 함수형 컴포넌트에 적절한 파라미터값을 넣고 데이터를 mapping해서 출력한다. \n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react'; //react는 UI 라이브러리\nimport ReactDOM from 'react-dom'; //reactDOM은 리액트를 웹에 render하는걸 도와주는 모델\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n\n// ReactDOM.render(<App />,document.getElementById('root'));\n// ReactDOM이 render한다. 무엇을? app을!\n// 여기서 app을 App.js을 의미한다...\n// 그 컴포넌트, 즉 App를 render해야하는데... 어디에? id가 root인 곳에...\n// 이 root는 index.html에 존재한다.\n// 결국 이것은 한개의 컴포넌트를 render하고 있는 것이다... 그 컴포넌트의 이름이 app이고...\n// 이 app 컴포넌트 안에 여러 개의 컴포넌트를 만들 수 있음.\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nreportWebVitals();\n\n\n//정리\n//1. reactDOM은 1개의 컴포너트를 render\n//2. 그리고 그 document 안에는 root라는 id를 가진 요소가 있고,\n//3. 그 요소는 index.html파일에 존재한다.\n \n\n\n"],"sourceRoot":""}